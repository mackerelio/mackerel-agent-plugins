#!/usr/bin/env perl
use 5.014;
use warnings;
use utf8;
use autodie;
use IO::File;
use JSON::PP;

my $PLUGIN_PREFIX = 'mackerel-plugin-';
my $PACKAGE_NAME = 'mackerel-agent-plugins';

# refer Mackerel::ReleaseUtils
sub replace {
    my ($glob, $code) = @_;
    for my $file (glob $glob) {
        my $content = $code->(slurp_utf8($file), $file);
        $content .= "\n" if $content !~ /\n\z/ms;

        # for keeping permission
        append_file($file, $content);
    }
}

sub retrieve_plugins {
    # exclude plugins which has been moved to other repositories
    sort map {s/^$PLUGIN_PREFIX//; $_} grep { -e "$_/lib" } <$PLUGIN_PREFIX*>;
}

sub update_readme {
    my $plugins = shift;
    my $external_plugins = shift;

    my $doc_links = '';
    my %doc_links_lines;
    for my $plug (@$plugins) {
        $doc_links_lines{$plug} = "* [$PLUGIN_PREFIX$plug](./$PLUGIN_PREFIX$plug/README.md)\n"
    }
    for my $plug (@$external_plugins) {
        my $link = sprintf "https://%s/blob/main/README.md", $plug->{'repository'};
        $doc_links_lines{$plug->{name}} = "* [$PLUGIN_PREFIX$plug->{name}]($link)\n"
    }

    for my $key (sort keys %doc_links_lines) {
        $doc_links .= $doc_links_lines{$key};
    }

    replace 'README.md' => sub {
        my $readme = shift;
        my $plu_reg = qr/$PLUGIN_PREFIX[-0-9a-zA-Z_]+/;
        my $plu_reg_readme = qr/\.\/$PLUGIN_PREFIX[-0-9a-zA-Z_]+|https:\/\/github\.com\/mackerelio\/[-0-0a-zA-Z_]+\/blob\/main/;
        $readme =~ s!(?:\* \[$plu_reg\]\($plu_reg_readme/README\.md\)\n)+!$doc_links!ms;
        $readme;
    };
}

sub update_packaging_specs {
    my @plugins = @_;
    my $for_in = 'for i in ' . join(' ', @plugins) . '; do';

    my $replace_sub = sub {
        my $content = shift;
        $content =~ s/for i in.*?;\s*do/$for_in/ms;
        $content;
    };
    replace $_, $replace_sub for ("packaging/rpm/$PACKAGE_NAME*.spec", "packaging/deb*/debian/rules");

    write_file(
        'packaging/deb/debian/source/include-binaries',
        join("\n", map { "debian/$PLUGIN_PREFIX$_" } @plugins) . "\n"
    );
}

sub update_packaging_binaries_list {
    my @plugins = @_;
    write_file(
        'packaging/plugin-lists',
        join("\n", map { "$PLUGIN_PREFIX$_" } @plugins) . "\n"
    );
}

####
# file utility
####

sub slurp_utf8 {
    my $filename = shift;
    my $fh = IO::File->new($filename, "<:utf8");
    local $/;
    <$fh>;
}
sub write_file {
    my $filename = shift;
    my $content = shift;
    my $fh = IO::File->new($filename, ">:utf8");
    print $fh $content;
    $fh->close;
}
sub append_file {
    my $filename = shift;
    my $content = shift;
    my $fh = IO::File->new($filename, "+>:utf8");
    print $fh $content;
    $fh->close;
}

sub load_packaging_confg {
    decode_json(slurp_utf8('packaging/config.json'));
}

####
# some file generate task
####

sub subtask {
    my $config = load_packaging_confg;
    my @plugins = retrieve_plugins;
    update_readme(\@plugins, $config->{'external-plugins'});

    my @all_plugins = (
        @{ $config->{plugins} },
        map { $_->{name} } @{ $config->{'external-plugins'} },
    );
    update_packaging_specs(sort @all_plugins);
    update_packaging_binaries_list(sort @all_plugins);
}

subtask();

####
# go:generate task
####

my @plugins = sort @{ load_packaging_confg()->{plugins}};
my @external_plugins = sort @{ load_packaging_confg()->{'external-plugins'}};

sub resolve_package {
    my $plug = shift;
    $plug =~ s/-//g;
    "mp$plug";
}

my $imports = "";
my $case = "";
my $plugs = "";
for my $plug (@plugins) {
    my $pkg = "mp$plug";
       $pkg =~ s/-//g;
    $imports .= sprintf qq[\t"github.com/mackerelio/mackerel-agent-plugins/mackerel-plugin-%s/lib"\n], $plug;
    $case .= sprintf qq[\tcase "%s":\n\t\t%s.Do()\n], $plug, $pkg;
    $plugs .= sprintf qq[\t"%s",\n], $plug;
}
for my $pluginfo (@external_plugins) {
    my $plug = $pluginfo->{name};
    my $pkg = "mp$plug";
       $pkg =~ s/-//g;
    $imports .= sprintf qq[\t"%s/lib"\n], $pluginfo->{repository};
    $case .= sprintf qq[\tcase "%s":\n\t\t%s.Do()\n], $plug, $pkg;
    $plugs .= sprintf qq[\t"%s",\n], $plug;
}

my $mackerel_plugin_gen = qq!// Code generated by "tool/gen_mackerel_plugin.pl"; DO NOT EDIT
package main

import (
	"fmt"

$imports)

func runPlugin(plug string) error {
	switch plug {
${case}\tdefault:
		return fmt.Errorf("unknown plugin: %q", plug)
	}
	return nil
}

var plugins = []string{
$plugs}!;

say $mackerel_plugin_gen;
